package no;

public class No implements Comparable<No> {
	protected No dir = null;
	protected No esq = null;
	protected int qtd;
	protected int cod;
	
	public No (No dir, No esq, int qtd) //construtor destinado aos nós não folhas
	{
		this.dir = dir;
		this.esq = esq;
		this.qtd = qtd;
		this.cod = -1; //se o nó tiver o código como -1 significas que não possui um código
	}
	
	public No (int cod, int qtd) throws Exception //construtor destinado aos nós folhas
	{
		if (qtd < 1)
			throw new Exception("Quantidade inválida");
		
		if (cod < 0 || cod > 255)
			throw new Exception("Código inválido");
		
		this.cod = cod;
		this.qtd = qtd;
	}
	
	public No getDir()
	{
		return dir;
	}
	
	public void setDir( No dir)
	{
		this.dir = dir;
	}
	
	public No getEsq()
	{
		return esq;
	}
	
	public void setEsq( No esq)
	{
		this.esq = esq;
	}
	
	public int getQtd()
	{
		return qtd;
	}
	
	public void setQtd( int qtd) throws Exception
	{
		if (qtd < 1)
			throw new Exception("Quantidade inválida");
		
		this.qtd = qtd;
	}
	
	public int getCod()
	{
		return cod;
	}
	
	public void setCod( int cod) throws Exception
	{
		if (cod < -1 || cod > 255)
			throw new Exception("Código inválido");
		
		this.cod = cod;
	}
	
	public int mais(No outro)
	{
		return this.qtd+outro.qtd;
	}
	
	public String toString()
	{
		String ret = "cod: " + cod;
		ret += "\nqtd: " + qtd;
		
		return ret;
	}
	
	public int compareTo(No x)
	{
		if (this.qtd == x.qtd)
			return 0;
		if (this.qtd < x.qtd)
			return -1;
		else
			return 1;
	}
	
	public No[] ordenar(No[] vetor)
	{
		No[] ret = new No[vetor.length];
		
		No aux;
		int i, j;
		
		for(i = 0; i<vetor.length; i++)
		{
			for(j = 0; j<vetor.length; j++)
			{
				if(vetor[i].compareTo(vetor[j]) < 0)
				{
					aux = vetor[i]; 	
					vetor[i] = vetor[j];
					vetor[j] = aux;	
				}
			}
		}
		vetor[i] = null; // tira o menor do vetor antigo
		
		int atual = 0;
		
		ret[atual] = menor;
		
		return ret;
	}
}
